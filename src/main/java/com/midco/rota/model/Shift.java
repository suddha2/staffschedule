package com.midco.rota.model;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Optional;

import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import com.midco.rota.service.PeriodService;
import com.midco.rota.util.ShiftType;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;
import jakarta.persistence.PostLoad;
import jakarta.persistence.Transient;

@Entity
public class Shift {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	@Column(name = "shift_start")
	private LocalDate shiftStart;

	@Column(name = "shift_end")
	private LocalDate shiftEnd;

	@OneToOne(fetch = FetchType.EAGER) 
	@JoinColumn(name = "shift_template_id")
	private ShiftTemplate shiftTemplate;

	@Transient
	private String pairId;

	@Transient
	private Integer absoluteWeek;

//	@Transient
//	private LocalDate referenceDate;

	// ✅ ADDED: Generate pairId after loading from DB
	@PostLoad
	private void onLoad() {
		generatePairId();
	}

	// ✅ ADDED: Centralized pairId generation logic
	private void generatePairId() {
		if (shiftTemplate != null && shiftTemplate.getLocation() != null && shiftStart != null) {

			ShiftType type = shiftTemplate.getShiftType();

			// Only LONG_DAY and SLEEP_IN need pairId
			if (type == ShiftType.LONG_DAY || type == ShiftType.SLEEP_IN) {
				this.pairId = String.format("%s_%s", shiftTemplate.getLocation(), shiftStart.toString());
			}
		}
	}

	@Transient
	private static PeriodService periodService;

	public static void setPeriodService(PeriodService service) {
	    periodService = service;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public LocalDate getShiftStart() {
		return shiftStart;
	}

	public void setShiftStart(LocalDate shiftStart) {
		this.shiftStart = shiftStart;
		generatePairId(); // ✅ Regenerate if date changes
	}

	public ShiftTemplate getShiftTemplate() {
		return shiftTemplate;
	}

	public void setShiftTemplate(ShiftTemplate shiftTemplate) {
		this.shiftTemplate = shiftTemplate;
		generatePairId(); // ✅ Regenerate if template changes
	}

	public String getPairId() {
		// ✅ Lazy generation if somehow not set
		if (pairId == null) {
			generatePairId();
		}
		return pairId;
	}

	public void setPairId(String pairId) {
		this.pairId = pairId;
	}

	public Shift() {
		// Default constructor - pairId will be generated by @PostLoad
	}

	public Shift(LocalDate shiftDate, ShiftTemplate shiftTemplate, Integer absWeek) {
		this.shiftStart = shiftDate;
		this.shiftTemplate = shiftTemplate;
		this.shiftEnd = LocalDateTime.of(shiftDate, shiftTemplate.getEndTime()).toLocalDate();

		// Adjust date to cover overnight shifts
		if (LocalDateTime.of(shiftDate, shiftTemplate.getEndTime())
				.isBefore(LocalDateTime.of(shiftDate, shiftTemplate.getStartTime()))) {
			this.shiftEnd = this.shiftStart.plusDays(1);
		}

		// ✅ Generate pairId for new shifts
		generatePairId();
		this.absoluteWeek=absWeek;
	}



	public LocalDate getShiftEnd() {
		return shiftEnd;
	}

	public void setShiftEnd(LocalDate shiftEnd) {
		this.shiftEnd = shiftEnd;
	}

	public BigDecimal getDurationInHours() {
		Duration duration = Duration.between(shiftStart.atTime(shiftTemplate.getStartTime()),
				shiftEnd.atTime(shiftTemplate.getEndTime()));

		Duration breakDuration = Optional.ofNullable(shiftTemplate.getBreakStart())
				.flatMap(start -> Optional.ofNullable(shiftTemplate.getBreakEnd())
						.map(end -> Duration.between(shiftStart.atTime(start), shiftStart.atTime(end))))
				.orElse(Duration.ZERO);

		long minutes = duration.minus(breakDuration).toMinutes();
		BigDecimal hours = BigDecimal.valueOf(minutes).divide(BigDecimal.valueOf(60), 2, RoundingMode.HALF_UP);
		return hours;
	}

	public long getDurationInMins() {
		Duration duration = Duration.between(shiftStart.atTime(shiftTemplate.getStartTime()),
				shiftEnd.atTime(shiftTemplate.getEndTime()));

		Duration breakDuration = Duration.ZERO;
		if (shiftTemplate.getBreakStart() != null && shiftTemplate.getBreakEnd() != null) {
			LocalTime breakStart = shiftTemplate.getBreakStart();
			LocalTime breakEnd = shiftTemplate.getBreakEnd();

			long breakMins = Duration.between(breakStart, breakEnd).toMinutes();
			if (breakMins < 0) {
				breakMins += 24 * 60; // Break spans midnight
			}
			breakDuration = Duration.ofMinutes(breakMins);
		}

		long minutes = duration.minus(breakDuration).toMinutes();
		if (minutes < 0) {
			minutes += 24 * 60;
		}

		return minutes;
	}

	public Integer getAbsoluteWeek() {
	    // ✅ Calculate if null
	    if (absoluteWeek == null && periodService != null && shiftStart != null) {
	        absoluteWeek = periodService.getAbsoluteWeekNumber(shiftStart);
	    }
	    return absoluteWeek;
	}

	public void setAbsoluteWeek(Integer absoluteWeek) {
		this.absoluteWeek = absoluteWeek;
	}
}