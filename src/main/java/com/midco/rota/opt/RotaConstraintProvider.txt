package com.midco.rota.opt;

import java.time.DayOfWeek;
import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.temporal.WeekFields;
import java.util.List;
import java.util.Map;

import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;
import org.optaplanner.core.api.score.stream.Constraint;
import org.optaplanner.core.api.score.stream.ConstraintCollectors;
import org.optaplanner.core.api.score.stream.ConstraintFactory;
import org.optaplanner.core.api.score.stream.ConstraintProvider;
import org.optaplanner.core.api.score.stream.Joiners;
import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.midco.rota.ShiftTypeLimitConfig;
import com.midco.rota.model.Employee;
import com.midco.rota.model.Shift;
import com.midco.rota.model.ShiftAssignment;
import com.midco.rota.service.RosterAnalysisService;
import com.midco.rota.util.ContractType;
import com.midco.rota.util.Gender;
import com.midco.rota.util.IdealShiftCount;
import com.midco.rota.util.ShiftType;

public class RotaConstraintProvider implements ConstraintProvider {

	private static final Logger logger = LoggerFactory.getLogger(RotaConstraintProvider.class);

	public RotaConstraintProvider() {

	}

	@Override
	public Constraint[] defineConstraints(ConstraintFactory factory) {

		return new Constraint[] {
				// rewardOneShiftPerDay(factory),
				unassignedShiftConstraint(factory), 
				allEmployeesHaveAtLeastOneShiftPerDay(factory),
				//noBackToBack(factory),
				// evenDistribution(factory),
				rewardAssignedShift(factory), 
				genderConstraint(factory), 
				preferedWorkingDaysConstraint(factory),
				preferredLocationConstraint(factory), preferedShiftTypeConstraint(factory),
				restrictedDayOfWeekConstraint(factory), restrictedShiftTypeConstraint(factory),
				restrictedServiceConstraint(factory), maxWeeklyHoursConstraint(factory),
				minWeeklyHoursConstraint(factory), preventDuplicateAssignments(factory),
				tooManyEmployeesPerShift(factory), prioritizedAllocation(factory), maxHoursPerShiftTypePerDay(factory),
				prioritizeHighPriorityLocations(factory), limitWeeklyShiftTypeCounts(factory),
				maxFourShiftsPerLocation(factory),
				};
	}

	private Constraint preventDuplicateAssignments(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class)
				.filter(assignment -> assignment.getEmployee() != null)
				.groupBy(assignment -> assignment.getShift(), assignment -> assignment.getEmployee(),
						ConstraintCollectors.count())
				.filter((shift, employee, count) -> count > 1).penalize(HardSoftScore.ONE_HARD)
				.asConstraint("Duplicate assignment of employee to same shift");
	}



	private Constraint rewardAssignedShift(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> sa.getEmployee() != null)
				.reward(HardSoftScore.ONE_SOFT).asConstraint("Assigned shift");
	}

	private Constraint noBackToBack(ConstraintFactory factory) {
		return factory.forEach(ShiftAssignment.class)
				.join(ShiftAssignment.class, Joiners.equal(ShiftAssignment::getEmployee),
						Joiners.lessThan(assignment -> assignment.getShift().getShiftStart())) // optional: avoids
																								// duplicate pairs
				.filter((sa1, sa2) -> isBackToBack(sa1, sa2)).penalize(HardSoftScore.ofHard(2000))
				.asConstraint("No back-to-back shifts");
	}

	private Constraint genderConstraint(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> {
			Employee employees = sa.getEmployee();
			Gender required = sa.getShift().getShiftTemplate().getGender();

			// If no gender requirement, allow all
			if (required == Gender.ANY || employees == null) {
				return false;
			}

			// Penalize if none of the assigned employees match the required gender
			return employees.getGender() != required;
		}).penalize(HardSoftScore.ofHard(1000), sa -> 1).asConstraint("Gender mismatch");
	}

	private boolean isBackToBack(ShiftAssignment sa1, ShiftAssignment sa2) {
//		DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("H:mm");

		// Safely parse dates and times
		LocalDate date1 = sa1.getShift().getShiftStart();
		LocalDate date2 = sa2.getShift().getShiftStart();

		LocalTime start1 = sa1.getShift().getShiftTemplate().getStartTime();
		LocalTime end1 = sa1.getShift().getShiftTemplate().getEndTime();
		LocalTime start2 = sa2.getShift().getShiftTemplate().getStartTime();
		LocalTime end2 = sa2.getShift().getShiftTemplate().getEndTime();

		if (start1 == null || end1 == null || start2 == null || end2 == null) {
			return false; // Invalid time format
		}

		LocalDateTime shift1End = LocalDateTime.of(date1, end1);
		LocalDateTime shift2Start = LocalDateTime.of(date2, start2);

		ShiftType type1 = sa1.getShift().getShiftTemplate().getShiftType();
		ShiftType type2 = sa2.getShift().getShiftTemplate().getShiftType();

		// 1. Same-day adjacent shift types (ordinal difference = 1)
		if (date1.equals(date2) && Math.abs(type1.ordinal() - type2.ordinal()) == 1) {
			return true;
		}

		// 2. Overnight transition: WAKING_NIGHT → DAY or LONG_DAY
		if (date1.plusDays(1).equals(date2) && type1 == ShiftType.WAKING_NIGHT
				&& (type2 == ShiftType.DAY || type2 == ShiftType.LONG_DAY)) {
			return true;
		}

		// 3. Reverse overnight: DAY or LONG_DAY → WAKING_NIGHT
		if (date2.plusDays(1).equals(date1) && type2 == ShiftType.WAKING_NIGHT
				&& (type1 == ShiftType.DAY || type1 == ShiftType.LONG_DAY)) {
			return true;
		}

		// 4. Overlapping or touching shifts on same day
		// if (date1.equals(date2) && !end1.isBefore(start2) && !start1.isAfter(end2)) {
		if (start1.isBefore(end2) && end1.isAfter(start2)) {
			return true;
		}

		// 5. Short rest period between shifts (<12 hours)
		if (shift1End.isBefore(shift2Start)) {
			long restHours = Duration.between(shift1End, shift2Start).toHours();
			if (restHours >= 0 && restHours < 12) {
				return true;
			}
		}

		return false;
	}

//	private Constraint allEmployeesHaveAtLeastOneShiftPerDay(ConstraintFactory factory) {
//		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> sa.getEmployee() != null)
//				.groupBy(sa -> sa.getEmployee(), sa -> sa.getShift().getShiftStart(), ConstraintCollectors.count())
//				.filter((employee, date, count) -> count == 0)
//				.penalize(HardSoftScore.ONE_HARD, (employee, date, count) -> 1)
//				.asConstraint("Employee must have at least one shift per day");
//	}

	private Constraint allEmployeesHaveAtLeastOneShiftPerDay(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(Employee.class)
				.join(factory.forEachIncludingNullVars(ShiftAssignment.class).map(sa -> sa.getShift().getShiftStart())
						.distinct())
				.ifNotExists(ShiftAssignment.class,
						Joiners.equal((employee, date) -> employee, ShiftAssignment::getEmployee),
						Joiners.equal((employee, date) -> date, sa -> sa.getShift().getShiftStart()))
				.penalize(HardSoftScore.ONE_HARD).asConstraint("Employee missing shift on date");
	}
	
	

	private Constraint evenDistribution(ConstraintFactory factory) {
		// 1) Count shifts per employee
		BiConstraintStream<Employee, Integer> countPerEmp = factory.forEachIncludingNullVars(ShiftAssignment.class)
				.filter(sa -> sa.getEmployee() != null)
				.groupBy(ShiftAssignment::getEmployee, ConstraintCollectors.count());

		// 2) Join that with our single IdealShiftCount fact
		return countPerEmp.join(IdealShiftCount.class)
				// 3) Penalize deviation
				.reward(HardSoftScore.ONE_SOFT,
						(employee, actualCount, idealFact) -> Math
								.abs(actualCount.intValue() - idealFact.getIdealCount()))
				.asConstraint("Even distribution");
	}

	private Constraint preferedWorkingDaysConstraint(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> {
			Employee emp = sa.getEmployee();
			if (emp == null || emp.getPreferredDay() == null)
				return false;

			DayOfWeek shiftDay = sa.getShift().getShiftStart().getDayOfWeek();
			return emp.getPreferredDay().contains(shiftDay);
		}).reward(HardSoftScore.ONE_SOFT).asConstraint("Prefer working on preferred days");
	}

	private Constraint preferredLocationConstraint(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> {
			Employee emp = sa.getEmployee();
			return emp != null && emp.getPreferredService() != null;
		}).reward(HardSoftScore.ONE_SOFT, sa -> {
			Employee emp = sa.getEmployee();
			String shiftLocation = sa.getShift().getShiftTemplate().getLocation();

			List<String> preferences = emp.getPreferredService();
			int index = preferences.indexOf(shiftLocation);

			if (index == -1)
				return 0; // not preferred

			// Higher reward for higher priority (e.g., top = highest score)
			return preferences.size() - index;
		}).asConstraint("Prefer working at preferred service (prioritized)");
	}

	private Constraint preferedShiftTypeConstraint(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> {
			Employee emp = sa.getEmployee();
			if (emp == null || emp.getPreferredShift() == null)
				return false;

			ShiftType shiftType = sa.getShift().getShiftTemplate().getShiftType();
			return emp.getPreferredShift().contains(shiftType);
		}).reward(HardSoftScore.ONE_SOFT).asConstraint("Prefer working on preferred shift");
	}

	public Constraint restrictedDayOfWeekConstraint(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> {
			Employee emp = sa.getEmployee();
			return emp != null && emp.getRestrictedDay() != null
					&& emp.getRestrictedDay().contains(sa.getShift().getShiftTemplate().getDay());
		}).penalize(HardSoftScore.ONE_HARD).asConstraint("Restricted day of week");
	}

	private Constraint restrictedShiftTypeConstraint(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> {
			Employee emp = sa.getEmployee();
			return emp != null && emp.getRestrictedShift() != null
					&& emp.getRestrictedShift().contains(sa.getShift().getShiftTemplate().getShiftType());
		}).penalize(HardSoftScore.ONE_HARD).asConstraint("Restricted Shift Type");
	}

	private Constraint restrictedServiceConstraint(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> {
			Employee emp = sa.getEmployee();
			return emp != null && emp.getRestrictedService() != null
					&& emp.getRestrictedService().contains(sa.getShift().getShiftTemplate().getLocation());
		}).penalize(HardSoftScore.ONE_HARD).asConstraint("Restricted Service");
	}

	private Constraint maxWeeklyHoursConstraint(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> sa.getEmployee() != null)
				.groupBy(ShiftAssignment::getEmployee, sa -> sa.getShift().getShiftStart().with(DayOfWeek.MONDAY),
						ConstraintCollectors.sumLong(sa -> {
							LocalTime start = sa.getShift().getShiftTemplate().getStartTime();
							LocalTime end = sa.getShift().getShiftTemplate().getEndTime();
							return Duration.between(start, end).toMinutes();
						}))
				.filter((employee, weekStart, totalMinutes) -> totalMinutes > (employee.getMaxHrs().longValue() * 60))
				.penalize(HardSoftScore.ONE_HARD,
						(employee, weekStart, totalMinutes) -> Long
								.valueOf(totalMinutes - (employee.getMaxHrs().longValue() * 60)).intValue())
				.asConstraint("Max weekly hours exceeded");
	}

	private Constraint minWeeklyHoursConstraint(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> sa.getEmployee() != null)
				.groupBy(ShiftAssignment::getEmployee, sa -> sa.getShift().getShiftStart().with(DayOfWeek.MONDAY),
						ConstraintCollectors.sumLong(sa -> {
							LocalTime start = sa.getShift().getShiftTemplate().getStartTime();
							LocalTime end = sa.getShift().getShiftTemplate().getEndTime();
							return Duration.between(start, end).toMinutes();
						}))
				.filter((employee, weekStart, totalMinutes) -> totalMinutes < (employee.getMinHrs().longValue() * 60))
				.penalize(HardSoftScore.ONE_HARD, (employee, weekStart, totalMinutes) -> {
					long minMinutes = employee.getMinHrs().longValue() * 60;
					return (int) (minMinutes - totalMinutes);
				}).asConstraint("Min weekly hours not met");
	}

	private Constraint unassignedShiftConstraint(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> {
			return sa.getEmployee() == null;
		}).penalize(HardSoftScore.ONE_HARD).asConstraint("Unassigned shift");
	}

	private Constraint tooManyEmployeesPerShift(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class)
				.groupBy(ShiftAssignment::getShift, ConstraintCollectors.count())
				.filter((shift, count) -> count > shift.getShiftTemplate().getEmpCount())
				.penalize(HardSoftScore.ONE_HARD).asConstraint("Too many employees for shift");
	}

	private Constraint prioritizedAllocation(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class)
				.filter(assignment -> assignment.getEmployee() != null).reward(HardSoftScore.ONE_SOFT, assignment -> {
					ShiftType shiftType = assignment.getShift().getShiftTemplate().getShiftType();
					ContractType contractType = assignment.getEmployee().getContractType();

					int shiftWeight = switch (shiftType) {
					case WAKING_NIGHT -> 40;
					case LONG_DAY -> 30;
					case DAY -> 20;
					case FLOATING -> 0;
					default -> 1;
					};

					int contractWeight = contractType.getPriority();

					return shiftWeight + contractWeight;
				}).asConstraint("Allocated shift weighted by shift type and contract type");
	}

	private Constraint oneShiftPerDayPerEmp(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class)
				.groupBy(ShiftAssignment::getEmployee, ShiftAssignment::getShift, ConstraintCollectors.count())
				.filter((employee, date, count) -> count > 1)
				.penalize(HardSoftScore.ONE_SOFT, (employee, date, count) -> count - 1)
				.asConstraint("Employee has multiple shifts per day");
	}

	private Constraint maxHoursPerShiftTypePerDay(ConstraintFactory factory) {

		Map<ShiftType, Integer> maxHoursPerShiftType = ShiftTypeLimitConfig.maxHoursPerShiftType();

		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> sa.getEmployee() != null)
				.groupBy(sa -> sa.getEmployee(), sa -> sa.getShift().getShiftStart(),
						sa -> sa.getShift().getShiftTemplate().getShiftType(),
						ConstraintCollectors.sum(sa -> sa.getShift().getDurationInHours()))
				.filter((employee, date, shiftType, totalHours) -> {
					Integer maxAllowed = maxHoursPerShiftType.getOrDefault(shiftType, Integer.MAX_VALUE);
					return totalHours > maxAllowed;
				}).penalize(HardSoftScore.ONE_HARD, (employee, date, shiftType, totalHours) -> {
					int maxAllowed = maxHoursPerShiftType.getOrDefault(shiftType, 0);
					return totalHours - maxAllowed;
				}).asConstraint("Max hours per shift type per day");
	}

	private Constraint prioritizeHighPriorityLocations(ConstraintFactory factory) {
		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> sa.getEmployee() != null)
				.reward(HardSoftScore.ONE_SOFT, sa -> {
					int priority = sa.getShift().getShiftTemplate().getPriority(); // 1 = high, 2 = medium, 3 = low
					return switch (priority) {
					case 1 -> 100; // High priority → highest reward
					case 2 -> 50; // Medium priority
					case 3 -> 10; // Low priority → lowest reward
					default -> 0; // Unknown or unranked
					};
				}).asConstraint("Prioritize high-priority location assignments");
	}

	private Constraint limitWeeklyShiftTypeCounts(ConstraintFactory factory) {

		Map<ShiftType, Integer> weeklyShiftTypeLimit = ShiftTypeLimitConfig.weeklyShiftTypeLimit();
		return factory.forEachIncludingNullVars(ShiftAssignment.class).filter(sa -> sa.getEmployee() != null)
				.groupBy(sa -> sa.getEmployee(), sa -> sa.getShift().getShiftTemplate().getShiftType(),
						sa -> YearWeek.from(sa.getShift().getShiftEnd()), ConstraintCollectors.count())
				.filter((emp, type, week, count) -> count > weeklyShiftTypeLimit.getOrDefault(type, 0))
				.penalize(HardSoftScore.ONE_HARD,
						(emp, type, week, count) -> count - weeklyShiftTypeLimit.getOrDefault(type, 0))
				.asConstraint("Weekly limit per shift type");
	}

	private Constraint maxFourShiftsPerLocation(ConstraintFactory constraintFactory) {
		return constraintFactory.forEachIncludingNullVars(ShiftAssignment.class)
				.filter(assignment -> assignment.getEmployee() != null)
				.filter(assignment -> !assignment.getShift().getShiftTemplate().getShiftType()
						.equals(ShiftType.FLOATING))
				.groupBy(assignment -> assignment.getEmployee(),
						assignment -> assignment.getShift().getShiftTemplate().getLocation(),
						ConstraintCollectors.count())
				.filter((employee, location, count) -> count > 4)
				.penalize(HardSoftScore.ONE_HARD, (employee, location, count) -> count - 4)
				.asConstraint("Max 4 shifts per location");
	}

	
//	private Constraint permanentEmployeeMustBeAssignedPerDay(ConstraintFactory factory) {
//	    return factory.forEach(Employee.class)
//	        .filter(emp -> emp.getContractType() == ContractType.PERMANENT)
//	        .join(factory.forEach(Shift.class)
//	            .map(shift -> shift.getShiftStart())
//	            .distinct())
//	        .ifNotExists(ShiftAssignment.class,
//	            Joiners.equal((emp, date) -> emp, ShiftAssignment::getEmployee),
//	            Joiners.equal((emp, date) -> date, sa -> sa.getShift().getShiftStart()))
//	        .penalize(HardSoftScore.ONE_HARD)
//	        .asConstraint("Permanent employee must be assigned per day");
//	}
	
	private record YearWeek(int year, int week) {
		public static YearWeek from(LocalDate date) {
			WeekFields wf = WeekFields.ISO;
			return new YearWeek(date.get(wf.weekBasedYear()), date.get(wf.weekOfWeekBasedYear()));
		}
	}

}
